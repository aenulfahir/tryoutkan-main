import { useState, useRef, useEffect } from "react";
import { cn } from "@/lib/utils";

interface ResponsiveImageProps {
  src: string;
  alt: string;
  className?: string;
  width?: string | number;
  height?: string | number;
  priority?: boolean;
  placeholder?: string;
  quality?: number;
  sizes?: string;
  fill?: boolean;
  style?: React.CSSProperties;
  onLoad?: () => void;
  onError?: () => void;
}

export function ResponsiveImage({
  src,
  alt,
  className,
  width,
  height,
  priority = false,
  placeholder = "blur",
  quality = 75,
  sizes,
  fill = false,
  style,
  onLoad,
  onError,
}: ResponsiveImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  // Lazy loading with Intersection Observer
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setIsInView(true);
          }
        });
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => {
      if (imgRef.current) {
        observer.unobserve(imgRef.current);
      }
    };
  }, []);

  // Handle image load
  const handleImageLoad = () => {
    setIsLoaded(true);
    onLoad?.();
  };

  // Handle image error
  const handleImageError = () => {
    setHasError(true);
    onError?.();
  };

  // Generate responsive srcset
  const generateSrcSet = (baseSrc: string, quality: number) => {
    // For demonstration, generate 3 sizes: 640w, 768w, 1024w
    // In production, this would be generated by an image service
    return `${baseSrc}?w=640&q=${quality} 640w, ${baseSrc}?w=768&q=${quality} 768w, ${baseSrc}?w=1024&q=${quality} 1024w`;
  };

  // Generate responsive sizes
  const generateSizes = () => {
    // For demonstration, generate 3 sizes
    // In production, this would be calculated based on layout
    return "(max-width: 640px) 640px, (max-width: 768px) 768px, 1024px";
  };

  // Determine image source
  const imageSrc = priority ? src : isInView ? src : "";
  const imageSrcSet = priority
    ? generateSrcSet(src, quality)
    : isInView
    ? generateSrcSet(src, quality)
    : "";
  const imageSizes = priority
    ? generateSizes()
    : isInView
    ? generateSizes()
    : "";

  // Placeholder for lazy loading
  const placeholderStyle: React.CSSProperties = {
    filter: "blur(20px)",
    transform: "scale(1.1)",
    transition: "filter 0.3s ease, transform 0.3s ease",
  };

  return (
    <div
      className={cn("relative overflow-hidden", className)}
      style={{
        width: width || "100%",
        height: height || "auto",
        ...style,
      }}
    >
      {/* Placeholder for lazy loading */}
      {!isLoaded && !hasError && (
        <div className="absolute inset-0 bg-muted" style={placeholderStyle} />
      )}

      {/* Actual image */}
      <img
        ref={imgRef}
        src={imageSrc}
        srcSet={imageSrcSet}
        sizes={imageSizes}
        alt={alt}
        width={width}
        height={height}
        loading={priority ? "eager" : "lazy"}
        decoding="async"
        className={cn(
          "w-full h-full object-cover transition-opacity duration-300",
          isLoaded ? "opacity-100" : "opacity-0",
          hasError && "opacity-0"
        )}
        onLoad={handleImageLoad}
        onError={handleImageError}
      />

      {/* Error state */}
      {hasError && (
        <div className="absolute inset-0 flex items-center justify-center bg-muted">
          <div className="text-center p-4">
            <svg
              className="w-12 h-12 mx-auto text-muted-foreground"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              strokeWidth="2"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M12 9v3.75m0 1.5c0 .414.336.75.75.75h1.5c.414 0 .75-.336.75-.75H12m0 3.75c0 .414.336.75.75.75h-1.5m0 1.5c-.414 0-.75.336-.75-.75H12"
              />
            </svg>
            <p className="mt-2 text-sm text-muted-foreground">
              Failed to load image
            </p>
          </div>
        </div>
      )}
    </div>
  );
}

// Hook for preloading critical images
export function useImagePreloader(images: string[]) {
  useEffect(() => {
    images.forEach((src) => {
      const img = new Image();
      img.src = src;
    });
  }, [images]);
}

// Hook for optimizing image loading
export function useImageOptimization() {
  const [isLowBandwidth, setIsLowBandwidth] = useState(false);

  useEffect(() => {
    // Detect connection speed (simplified)
    const connection = (navigator as any).connection || {};
    const effectiveType = connection.effectiveType || "";

    // Consider 2G, slow-2G, and 3G as low bandwidth
    if (
      effectiveType.includes("2g") ||
      effectiveType.includes("slow-2g") ||
      effectiveType.includes("3g")
    ) {
      setIsLowBandwidth(true);
    }
  }, []);

  return { isLowBandwidth };
}

// Component for optimized image gallery
interface ResponsiveImageGalleryProps {
  images: {
    src: string;
    alt: string;
    caption?: string;
  }[];
  className?: string;
  columns?: {
    xs?: number;
    sm?: number;
    md?: number;
    lg?: number;
    xl?: number;
  };
  gap?: string;
}

export function ResponsiveImageGallery({
  images,
  className,
  columns = { xs: 1, sm: 2, md: 3, lg: 4, xl: 5 },
  gap = "gap-4",
}: ResponsiveImageGalleryProps) {
  const [selectedImage, setSelectedImage] = useState(0);

  return (
    <div className={cn("w-full", className)}>
      {/* Thumbnail grid */}
      <div
        className={cn(
          "grid",
          `grid-cols-${columns.xs}`,
          `sm:grid-cols-${columns.sm}`,
          `md:grid-cols-${columns.md}`,
          `lg:grid-cols-${columns.lg}`,
          `xl:grid-cols-${columns.xl}`,
          gap
        )}
      >
        {images.map((image, index) => (
          <button
            key={index}
            type="button"
            onClick={() => setSelectedImage(index)}
            className={cn(
              "relative aspect-square overflow-hidden rounded-md border-2",
              selectedImage === index
                ? "border-primary ring-2 ring-primary ring-offset-2"
                : "border-border"
            )}
          >
            <ResponsiveImage
              src={image.src}
              alt={image.alt}
              width={150}
              height={150}
              quality={60}
              className="w-full h-full object-cover"
            />
          </button>
        ))}
      </div>

      {/* Selected image */}
      <div className="mt-4">
        <ResponsiveImage
          src={images[selectedImage]?.src || ""}
          alt={images[selectedImage]?.alt || ""}
          className="w-full rounded-lg"
        />
        {images[selectedImage]?.caption && (
          <p className="mt-2 text-sm text-muted-foreground">
            {images[selectedImage]?.caption}
          </p>
        )}
      </div>
    </div>
  );
}
